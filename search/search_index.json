{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"atomphys A Python package to help with atomic physics calculations. Documentation : mgrau.github.io/atomphys/ Source Code : github.com/mgrau/atomphys atomphys is meant to be a good starting off point for your atomic physics calculations. It can automate much of the frustrating process of searching for and compiling physical data and simple pyhsical relations, and help you more quickly get to the good stuff. It's designed with a natural interface and is easy to use. Example >>> from atomphys import Atom >>> Rb = Atom ( 'Rb' ) >>> print ( Rb ( 'S1/2' ) . to ( 'P1/2' ) . \u03bb . to ( 'nm' )) 795 nm >>> print ( Rb ( 'P1/2' ) . \u03c4 . to ( 'ns' )) 27.7 ns Installation To install atomphys, simply use pip: $ pip install atomphys Features Integration with Pint for robust handling of units Automatically fetch energy level and transition data from the NIST Atomic Spectra Database Use transition data to calculation state lifetimes, polarizabilities, transition dipole moments, cross sections, and saturation intensities Requirements Python 3.6+ atomphys makes extensive use of the excellent package Pint to handle units.","title":"Home"},{"location":"#atomphys","text":"A Python package to help with atomic physics calculations. Documentation : mgrau.github.io/atomphys/ Source Code : github.com/mgrau/atomphys atomphys is meant to be a good starting off point for your atomic physics calculations. It can automate much of the frustrating process of searching for and compiling physical data and simple pyhsical relations, and help you more quickly get to the good stuff. It's designed with a natural interface and is easy to use.","title":"atomphys"},{"location":"#example","text":">>> from atomphys import Atom >>> Rb = Atom ( 'Rb' ) >>> print ( Rb ( 'S1/2' ) . to ( 'P1/2' ) . \u03bb . to ( 'nm' )) 795 nm >>> print ( Rb ( 'P1/2' ) . \u03c4 . to ( 'ns' )) 27.7 ns","title":"Example"},{"location":"#installation","text":"To install atomphys, simply use pip: $ pip install atomphys","title":"Installation"},{"location":"#features","text":"Integration with Pint for robust handling of units Automatically fetch energy level and transition data from the NIST Atomic Spectra Database Use transition data to calculation state lifetimes, polarizabilities, transition dipole moments, cross sections, and saturation intensities","title":"Features"},{"location":"#requirements","text":"Python 3.6+ atomphys makes extensive use of the excellent package Pint to handle units.","title":"Requirements"},{"location":"developers/","text":"Developer Guide You can contribute to atomphys in different ways. Report issues You can report bugs with the package and gaps in documentation on github in the issue tracker . Feel free to also submit feature requests, ask questions, or open general discussions. Building the code To contribute to the code or documentation, you will need a suitable python development environment. If you are just getting started we recommend that you clone atomphys from github. $ git clone git@github.com:mgrau/atomphys.git $ cd atomphys We recommend create a new python virtual environment for development, $ python3 -m venv atomphys_venv $ source atomphys_venv/bin/activate and install atomphys in editable mode, with the optional dependencies for development or for building documentation. $ pip install -e . $ pip install -r requirements_dev.txt $ pip install -r requirements_docs.txt Install the git hook scripts which performs automated checks of code style before commit $ pre-commit install Running tests Run unit tests using pytest. $ pytest You can also run the full suite of tests against every atom in the NIST ASD (warning: this is very slow!) $ pytest -m ASD Building documentation You can build the documentatio and run it in a test server with mkdocs, $ mkdocs serve","title":"Developers"},{"location":"developers/#developer-guide","text":"You can contribute to atomphys in different ways.","title":"Developer Guide"},{"location":"developers/#report-issues","text":"You can report bugs with the package and gaps in documentation on github in the issue tracker . Feel free to also submit feature requests, ask questions, or open general discussions.","title":"Report issues"},{"location":"developers/#building-the-code","text":"To contribute to the code or documentation, you will need a suitable python development environment. If you are just getting started we recommend that you clone atomphys from github. $ git clone git@github.com:mgrau/atomphys.git $ cd atomphys We recommend create a new python virtual environment for development, $ python3 -m venv atomphys_venv $ source atomphys_venv/bin/activate and install atomphys in editable mode, with the optional dependencies for development or for building documentation. $ pip install -e . $ pip install -r requirements_dev.txt $ pip install -r requirements_docs.txt Install the git hook scripts which performs automated checks of code style before commit $ pre-commit install","title":"Building the code"},{"location":"developers/#running-tests","text":"Run unit tests using pytest. $ pytest You can also run the full suite of tests against every atom in the NIST ASD (warning: this is very slow!) $ pytest -m ASD","title":"Running tests"},{"location":"developers/#building-documentation","text":"You can build the documentatio and run it in a test server with mkdocs, $ mkdocs serve","title":"Building documentation"},{"location":"getting-started/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Getting Started To get started with atomphys, you can install it with pip: $ pip install atomphys Alternatively, you can run any of these examples in binder without any installation simply by clicking the link at the top of the page. To start with, import the Atom object, and use it to create a Cesium atom. By default, this will automatically populate with all of the states and transitions in the NIST Atomic Spectra Database. from atomphys import Atom Cs = Atom ( 'Cs' ) Cs Ground State: State(6s 2S1/2: 0 E_h) 179 States 42 Transitions States You can then lookup states either by index (the states are energy ordered), or by searching by term symbol: Cs [ 1 ] State(6p 2P1/2*: 0.05093 E_h) Cs ( 'P3/2' ) State(6p 2P3/2*: 0.05346 E_h) You can access properties of a state like the energy or lifetime. Cs ( 'P1/2' ) . energy 0.050931937278 E_h Cs ( 'P1/2' ) . \u03c4 1443987891.5537002 \u0127/E_h Cs ( 'P1/2' ) . lifetime 1443987891.5537002 \u0127/E_h By default atomphys uses atomic units . You can use pint to convert to units of your choice. Cs ( 'P1/2' ) . \u03c4 . to ( 'ns' ) 34.92839678658749 ns ( 1 / Cs ( 'P1/2' ) . lifetime ) . to ( 'MHz' ) 28.63000000000001 MHz Transitions You can access transitions origination from a state, Cs ( 'S1/2' ) . to ( 'P1/2' ) Transition(6s 2S1/2 <---> 6p 2P1/2*, \u03bb=894.6 nm, \u0393=2\u03c0\u00d74.557 MHz) as well as properties of that transition, such as wavelength, dipole matrix element, and saturation intensity Cs ( 'S1/2' ) . to ( 'P1/2' ) . \u03bb . to ( 'nm' ) 894.5929600207925 nm Cs ( 'S1/2' ) . to ( 'P1/2' ) . reduced_dipole_matrix_element . to ( 'e a0' ) 4.498115119474812 a_0 e Cs ( 'S1/2' ) . to ( 'P1/2' ) . Isat . to ( 'mW/cm^2' ) 0.8318600537758196 mW/cm 2","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"To get started with atomphys, you can install it with pip: $ pip install atomphys Alternatively, you can run any of these examples in binder without any installation simply by clicking the link at the top of the page. To start with, import the Atom object, and use it to create a Cesium atom. By default, this will automatically populate with all of the states and transitions in the NIST Atomic Spectra Database. from atomphys import Atom Cs = Atom ( 'Cs' ) Cs Ground State: State(6s 2S1/2: 0 E_h) 179 States 42 Transitions","title":"Getting Started"},{"location":"getting-started/#states","text":"You can then lookup states either by index (the states are energy ordered), or by searching by term symbol: Cs [ 1 ] State(6p 2P1/2*: 0.05093 E_h) Cs ( 'P3/2' ) State(6p 2P3/2*: 0.05346 E_h) You can access properties of a state like the energy or lifetime. Cs ( 'P1/2' ) . energy 0.050931937278 E_h Cs ( 'P1/2' ) . \u03c4 1443987891.5537002 \u0127/E_h Cs ( 'P1/2' ) . lifetime 1443987891.5537002 \u0127/E_h By default atomphys uses atomic units . You can use pint to convert to units of your choice. Cs ( 'P1/2' ) . \u03c4 . to ( 'ns' ) 34.92839678658749 ns ( 1 / Cs ( 'P1/2' ) . lifetime ) . to ( 'MHz' ) 28.63000000000001 MHz","title":"States"},{"location":"getting-started/#transitions","text":"You can access transitions origination from a state, Cs ( 'S1/2' ) . to ( 'P1/2' ) Transition(6s 2S1/2 <---> 6p 2P1/2*, \u03bb=894.6 nm, \u0393=2\u03c0\u00d74.557 MHz) as well as properties of that transition, such as wavelength, dipole matrix element, and saturation intensity Cs ( 'S1/2' ) . to ( 'P1/2' ) . \u03bb . to ( 'nm' ) 894.5929600207925 nm Cs ( 'S1/2' ) . to ( 'P1/2' ) . reduced_dipole_matrix_element . to ( 'e a0' ) 4.498115119474812 a_0 e Cs ( 'S1/2' ) . to ( 'P1/2' ) . Isat . to ( 'mW/cm^2' ) 0.8318600537758196 mW/cm 2","title":"Transitions"},{"location":"reference/","text":"Reference atom Atom An atom object, containing states and transitions Attributes: Name Type Description name str The name of the atom states : StateRegistry property readonly StateRegistry: the atomic states. transitions : TransitionRegistry property readonly TransitionRegistry: the atomic transitions. units property readonly pint.UnitRegistry(): readonly access to the pint UnitRegistry used by the atom. calc special polarizability scalar ( state , omega = 0 ) Calculate the scalar polarizability of a state |\u03a8\u27e9 Approximate the dynamical scalar polarizability \u03b10(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements \\[ \\alpha^0(\\omega) = \\frac{1}{3(2J+1)} \\sum_i \\left( \\frac{1}{\\hbar (E_i - E) - \\hbar \\omega} + \\frac{1}{\\hbar (E_i - E) + \\hbar \\omega} \\right) \\left|\\left<\\Psi\\left|D\\right| \\Psi_i\\right>\\right|^2 \\] Parameters: Name Type Description Default state State state |\u03a8\u27e9 to calculate the polarizability required omega Quantity Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of Hz . 0 Returns: Type Description Quantity Scalar polarizability. Has units of C m / (V/m) , or dipole moment / electric field. Source code in atomphys/calc/polarizability.py def scalar ( state , omega : pint . Quantity = 0 ) -> pint . Quantity : \"\"\"Calculate the scalar polarizability of a state |\u03a8\u27e9 Approximate the dynamical scalar polarizability \u03b10(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements $$ \\\\alpha^0(\\\\omega) = \\\\frac{1}{3(2J+1)} \\\\sum_i \\\\left( \\\\frac{1}{\\\\hbar (E_i - E) - \\\\hbar \\\\omega} + \\\\frac{1}{\\\\hbar (E_i - E) + \\\\hbar \\\\omega} \\\\right) \\\\left|\\\\left<\\\\Psi\\\\left|D\\\\right| \\\\Psi_i\\\\right>\\\\right|^2 $$ Arguments: state (State): state |\u03a8\u27e9 to calculate the polarizability omega: Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of `Hz`. Returns: Scalar polarizability. Has units of `C m / (V/m)`, or dipole moment / electric field. \"\"\" \u03c9 = omega \u0127 = state . _ureg [ \"\u0127\" ] J = state . J X = 1 / ( 3 * ( 2 * J + 1 )) / \u0127 \u03b1 = 0 for transition in state . up : \u03c90 = transition . \u03c9 d = transition . reduced_dipole_matrix_element \u03b1 += ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 for transition in state . down : \u03c90 = - transition . \u03c9 d = transition . reduced_dipole_matrix_element_conjugate \u03b1 += ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 return ( \u03b1 * X ) . to_base_units () tensor ( state , omega = 0 ) Calculate the tensor polarizability of a state |\u03a8\u27e9 Approximate the dynamical tensor polarizability \u03b10(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements \\[ \\alpha^1(\\omega) = -\\sqrt{\\frac{20J(2J-1)}{6(J+1)(2J+1)(2J+3)}} \\sum_i \\left\\{ \\begin{matrix} 1 & 1 & 1 \\\\ J & J & J_i \\end{matrix} \\right\\} (-1)^{1+J+J_i} \\left( \\frac{1}{\\hbar (E_i - E) - \\hbar \\omega} + \\frac{1}{\\hbar (E_i - E) + \\hbar \\omega}\\right) \\left| \\left<\\Psi\\left|D\\right| \\Psi_i\\right>\\right|^2 \\] Parameters: Name Type Description Default state State state |\u03a8\u27e9 to calculate the polarizability required omega Quantity Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of Hz . 0 Returns: Type Description Tensor polarizability. Has units of C m / (V/m) , or dipole moment / electric field. Source code in atomphys/calc/polarizability.py def tensor ( state , omega : pint . Quantity = 0 ): \"\"\"Calculate the tensor polarizability of a state |\u03a8\u27e9 Approximate the dynamical tensor polarizability \u03b10(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements \\\\[ \\\\alpha^1(\\\\omega) = -\\\\sqrt{\\\\frac{20J(2J-1)}{6(J+1)(2J+1)(2J+3)}} \\\\sum_i \\\\left\\\\{ \\\\begin{matrix} 1 & 1 & 1 \\\\\\\\ J & J & J_i \\\\end{matrix} \\\\right\\\\} (-1)^{1+J+J_i} \\\\left( \\\\frac{1}{\\\\hbar (E_i - E) - \\\\hbar \\\\omega} + \\\\frac{1}{\\\\hbar (E_i - E) + \\\\hbar \\\\omega}\\\\right) \\\\left| \\\\left<\\\\Psi\\\\left|D\\\\right| \\\\Psi_i\\\\right>\\\\right|^2 \\\\] Arguments: state (State): state |\u03a8\u27e9 to calculate the polarizability omega: Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of `Hz`. Returns: Tensor polarizability. Has units of `C m / (V/m)`, or dipole moment / electric field. \"\"\" \u03c9 = omega \u0127 = state . _ureg [ \"\u0127\" ] J = state . J X = ( - ( (( 20 * J * ( 2 * J - 1 )) / ( 6 * ( J + 1 ) * ( 2 * J + 1 ) * ( 2 * J + 3 ))) ** ( 1 / 2 ) ) / \u0127 ) \u03b1 = 0 for transition in state . up : \u03c90 = transition . \u03c9 d = transition . reduced_dipole_matrix_element Jp = transition . f . J sixJ = wigner_6j ( 1 , 1 , 2 , J , J , Jp ) \u03b1 += ( - 1 ) ** ( J + Jp + 1 ) * sixJ * ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 for transition in state . down : \u03c90 = - transition . \u03c9 d = transition . reduced_dipole_matrix_element_conjugate Jp = transition . i . J sixJ = wigner_6j ( 1 , 1 , 2 , J , J , Jp ) \u03b1 += ( - 1 ) ** ( J + Jp + 1 ) * sixJ * ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 return ( \u03b1 * X ) . to_base_units () total ( state , mJ = None , omega = 0 , A = 0 , theta_k = 0 , theta_p = 1.5707963267948966 ) Calculate the polarizability of a state for a given field polarization Calculates the dynamical polarizability \u03b1(\u03c9) by taking the sum of the scalar, vector, and tensor poarts according to \\[ \\alpha(\\omega) = \\alpha^0(\\omega) + A \\cos(\\theta_k) \\frac{m_J}{2J} \\alpha^1(\\omega) + \\frac{1}{2}\\left(3 \\cos^2(\\theta_p) - 1\\right)\\frac{3m_J^2 - J(J+1)}{J(2J-1)}\\alpha^2(\\omega) \\] Parameters: Name Type Description Default state State state |\u03a8\u27e9 to calculate the polarizability required mJ float Zeeman sublevel to calculate the vector and tensor polarizability. If None only calculates the scalar component. Must be an integer if J is an integer, or a half-integer if J is a half integer. None omega Quantity angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of Hz . 0 A float degree of circular polarization, with \u00b11 being circular polarization and 0 being linear polarization 0 theta_k float angle between wave vector and quantization axis 0 theta_p float angle between polarization vector and quantization axis 1.5707963267948966 Returns: Type Description Quantity Polarizability. Has units of C m / (V/m) , or dipole moment / electric field. Source code in atomphys/calc/polarizability.py def total ( state , mJ : float = None , omega : pint . Quantity = 0 , A : float = 0 , theta_k : float = 0 , theta_p : float = \u03c0 / 2 , ) -> pint . Quantity : \"\"\"Calculate the polarizability of a state for a given field polarization Calculates the dynamical polarizability \u03b1(\u03c9) by taking the sum of the scalar, vector, and tensor poarts according to \\\\[ \\\\alpha(\\\\omega) = \\\\alpha^0(\\\\omega) + A \\\\cos(\\\\theta_k) \\\\frac{m_J}{2J} \\\\alpha^1(\\\\omega) + \\\\frac{1}{2}\\\\left(3 \\\\cos^2(\\\\theta_p) - 1\\\\right)\\\\frac{3m_J^2 - J(J+1)}{J(2J-1)}\\\\alpha^2(\\\\omega) \\\\] Arguments: state (State): state |\u03a8\u27e9 to calculate the polarizability mJ: Zeeman sublevel to calculate the vector and tensor polarizability. If `None` only calculates the scalar component. Must be an integer if J is an integer, or a half-integer if J is a half integer. omega: angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of `Hz`. A: degree of circular polarization, with \u00b11 being circular polarization and 0 being linear polarization theta_k: angle between wave vector and quantization axis theta_p: angle between polarization vector and quantization axis Returns: Polarizability. Has units of `C m / (V/m)`, or dipole moment / electric field. Raises: ZeroDivisionError \"\"\" \u03b8k = theta_k \u03b8p = theta_p J = state . J \u03b10 = scalar ( state , omega ) \u03b11 = vector ( state , omega ) \u03b12 = tensor ( state , omega ) if mJ is None : return \u03b10 if not ( isint ( mJ ) or ( ishalfint ( mJ ) and ishalfint ( J ))): raise ValueError ( \"mJ must be an integer, or a half-integer if J is a half-integer\" ) C1 = A * cos ( \u03b8k ) * mJ / J try : C2 = ( ( 3 * cos ( \u03b8p ) ** 2 - 1 ) / 2 * ( 3 * mJ ** 2 - J * ( J + 1 )) / ( J * ( 2 * J - 1 )) ) except ZeroDivisionError : C2 = 0 return ( \u03b10 + C1 * \u03b11 + C2 * \u03b12 ) . to_base_units () vector ( state , omega = 0 ) Calculate the vector polarizability of a state |\u03a8\u27e9 Approximate the dynamical vector polarizability \u03b11(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements \\[ \\alpha^1(\\omega) = \\sqrt{\\frac{6J}{(J+1)(2J+1)}} \\sum_i \\left\\{ \\begin{matrix} 1 & 1 & 1 \\\\ J & J & J_i \\end{matrix} \\right\\} (-1)^{1+J+J_i} \\left( \\frac{1}{\\hbar (E_i - E) - \\hbar \\omega} + \\frac{1}{\\hbar (E_i - E) + \\hbar \\omega} \\right) \\left|\\left<\\Psi\\left|D\\right| \\Psi_i\\right>\\right|^2 \\] Parameters: Name Type Description Default state State state |\u03a8\u27e9 to calculate the polarizability required omega Quantity Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of Hz . 0 Returns: Type Description Vector polarizability. Has units of C m / (V/m) , or dipole moment / electric field. Source code in atomphys/calc/polarizability.py def vector ( state , omega : pint . Quantity = 0 ): \"\"\"Calculate the vector polarizability of a state |\u03a8\u27e9 Approximate the dynamical vector polarizability \u03b11(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements \\\\[ \\\\alpha^1(\\\\omega) = \\\\sqrt{\\\\frac{6J}{(J+1)(2J+1)}} \\\\sum_i \\\\left\\\\{ \\\\begin{matrix} 1 & 1 & 1 \\\\\\\\ J & J & J_i \\\\end{matrix} \\\\right\\\\} (-1)^{1+J+J_i} \\\\left( \\\\frac{1}{\\\\hbar (E_i - E) - \\\\hbar \\\\omega} + \\\\frac{1}{\\\\hbar (E_i - E) + \\\\hbar \\\\omega} \\\\right) \\\\left|\\\\left<\\\\Psi\\\\left|D\\\\right| \\\\Psi_i\\\\right>\\\\right|^2 \\\\] Arguments: state (State): state |\u03a8\u27e9 to calculate the polarizability omega: Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of `Hz`. Returns: Vector polarizability. Has units of `C m / (V/m)`, or dipole moment / electric field. \"\"\" \u03c9 = omega \u0127 = state . _ureg [ \"\u0127\" ] J = state . J X = (( 6 * J ) / ( 4 * ( 2 * J + 1 ) * ( J + 1 ))) ** ( 1 / 2 ) / \u0127 \u03b1 = 0 for transition in state . up : \u03c90 = transition . \u03c9 d = transition . reduced_dipole_matrix_element Jp = transition . f . J sixJ = wigner_6j ( 1 , 1 , 1 , J , J , Jp ) \u03b1 += ( - 1 ) ** ( J + Jp + 1 ) * sixJ * ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 for transition in state . down : \u03c90 = - transition . \u03c9 d = transition . reduced_dipole_matrix_element_conjugate Jp = transition . i . J sixJ = wigner_6j ( 1 , 1 , 1 , J , J , Jp ) \u03b1 += - (( - 1 ) ** ( J + Jp + 1 )) * sixJ * ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 return ( \u03b1 * X ) . to_base_units () wigner ishalfint ( x ) check if value is half integer Parameters: Name Type Description Default x float is this a half integer? required Returns: Type Description bool True if x is a half integer and False if it is not. Source code in atomphys/calc/wigner.py def ishalfint ( x : float ) -> bool : \"\"\"check if value is half integer Arguments: x: is this a half integer? Returns: True if x is a half integer and False if it is not. \"\"\" return 2 * x == floor ( 2 * x ) isint ( x ) checks if value is an integer Parameters: Name Type Description Default x float is this an integer? required Returns: Type Description bool True if x is an integer and False if it is not. Source code in atomphys/calc/wigner.py def isint ( x : float ) -> bool : \"\"\"checks if value is an integer Arguments: x: is this an integer? Returns: True if x is an integer and False if it is not. \"\"\" return x == floor ( x ) istriangle ( a , b , c ) checks if triad (a, b, c) obeys the triangle inequality Parameters: Name Type Description Default a float required b float required c float required Returns: Type Description bool True if the triangle inequality is satisfied and False if it is not. Source code in atomphys/calc/wigner.py def istriangle ( a : float , b : float , c : float ) -> bool : \"\"\"checks if triad (a, b, c) obeys the triangle inequality Arguments: a: b: c: Returns: True if the triangle inequality is satisfied and False if it is not. \"\"\" return abs ( a - b ) <= c and c <= a + b wigner_3j ( j1 , j2 , j3 , m1 , m2 , m3 ) Calculate the Wigner 3-j symbol numerically The Wigner 3-j symbol is calculated numerically using a recursion relation. This approximate calculation is often faster than the exact analytic calculation that is done by sympy.physics.wigner . Due to the finite precision of floating point numbers, this is only good for \\(j\\) and \\(m\\) up to about 40, after which it becomes too inaccurate. The results are cached in the private variable _wigner_3j_cache to speed subsequent calculations. \\(\\left( \\begin{matrix} j_1 & j_2 & j_3 \\\\ m_1 & m_2 & m_3 \\end{matrix} \\right)\\) Parameters: Name Type Description Default j1 float required j2 float required j3 float required m1 float required m2 float required m3 float required Returns: Type Description float \\(\\left( \\begin{matrix} j_1 & j_2 & j_3 \\\\ m_1 & m_2 & m_3 \\end{matrix} \\right)\\) Source code in atomphys/calc/wigner.py def wigner_3j ( j1 : float , j2 : float , j3 : float , m1 : float , m2 : float , m3 : float ) -> float : \"\"\"Calculate the Wigner 3-j symbol numerically The Wigner 3-j symbol is calculated numerically using a recursion relation. This approximate calculation is often faster than the exact analytic calculation that is done by `sympy.physics.wigner`. Due to the finite precision of floating point numbers, this is only good for $j$ and $m$ up to about 40, after which it becomes too inaccurate. The results are cached in the private variable `_wigner_3j_cache` to speed subsequent calculations. $\\\\left( \\\\begin{matrix} j_1 & j_2 & j_3 \\\\\\\\ m_1 & m_2 & m_3 \\\\end{matrix} \\\\right)$ Arguments: j1: j2: j3: m1: m2: m3: Returns: $\\\\left( \\\\begin{matrix} j_1 & j_2 & j_3 \\\\\\\\ m_1 & m_2 & m_3 \\\\end{matrix} \\\\right)$ \"\"\" if ( j1 , j2 , j3 , m1 , m2 , m3 ) in _wigner_3j_cache : return _wigner_3j_cache [( j1 , j2 , j3 , m1 , m2 , m3 )] if ( not ishalfint ( j1 ) or not ishalfint ( j2 ) or not ishalfint ( j3 ) or not ishalfint ( m1 ) or not ishalfint ( m2 ) or not ishalfint ( m3 ) ): raise ValueError ( \"All arguments must be integers or half-integers\" ) if j1 > 40 or j2 > 40 or j3 > 40 or m1 > 40 or m2 > 40 or m3 > 40 : raise OverflowError ( \"can't handle numbers this larger, use a sympy.physics.wigner\" ) # sum of second row must equal zero if m1 + m2 + m3 != 0 : return 0 # triangle inequality if not istriangle ( j1 , j2 , j3 ): return 0 if ( j1 - m1 != floor ( j1 - m1 ) or j2 - m2 != floor ( j2 - m2 ) or j3 - m3 != floor ( j3 - m3 ) ): return 0 if abs ( m1 ) > j1 or abs ( m2 ) > j2 or abs ( m3 ) > j3 : return 0 wigner = 0 for t in range ( int ( max ( 0 , j2 - m1 - j3 , j1 + m2 - j3 )), int ( min ( j1 + j2 - j3 , j1 - m1 , j2 + m2 )) + 1 , ): wigner += ( - 1 ) ** t / ( factorial ( t ) * factorial ( t - ( j2 - m1 - j3 )) * factorial ( t - ( j1 + m2 - j3 )) * factorial ( j1 + j2 - j3 - t ) * factorial ( j1 - m1 - t ) * factorial ( j2 + m2 - t ) ) wigner *= ( - 1 ) ** ( j1 - j2 - m3 ) * sqrt ( \u0394 ( j1 , j2 , j3 ) * factorial ( j1 + m1 ) * factorial ( j1 - m1 ) * factorial ( j2 + m2 ) * factorial ( j2 - m2 ) * factorial ( j3 + m3 ) * factorial ( j3 - m3 ) ) _wigner_3j_cache [( j1 , j2 , j3 , m1 , m2 , m3 )] = wigner return wigner wigner_6j ( j1 , j2 , j3 , J1 , J2 , J3 ) Calculate the Wigner 6-j symbol numerically The Wigner 6-j symbol is calculated numerically using a recursion relation. This approximate calculation is often faster than the exact analytic calculation that is done by sympy.physics.wigner . The results are cached in the private variable _wigner_6j_cache to speed subsequent calculations. \\(\\left\\{ \\begin{matrix} j_1 & j_2 & j_3 \\\\ J_1 & J_2 & J_3 \\end{matrix} \\right\\}\\) Parameters: Name Type Description Default j1 float required j2 float required j3 float required J1 float required J2 float required J3 float required Returns: Type Description float \\(\\left\\{ \\begin{matrix} j_1 & j_2 & j_3 \\\\ J_1 & J_2 & J_3 \\end{matrix} \\right\\}\\) Source code in atomphys/calc/wigner.py def wigner_6j ( j1 : float , j2 : float , j3 : float , J1 : float , J2 : float , J3 : float ) -> float : \"\"\"Calculate the Wigner 6-j symbol numerically The Wigner 6-j symbol is calculated numerically using a recursion relation. This approximate calculation is often faster than the exact analytic calculation that is done by `sympy.physics.wigner`. The results are cached in the private variable `_wigner_6j_cache` to speed subsequent calculations. $\\\\left\\\\{ \\\\begin{matrix} j_1 & j_2 & j_3 \\\\\\\\ J_1 & J_2 & J_3 \\\\end{matrix} \\\\right\\\\}$ Arguments: j1: j2: j3: J1: J2: J3: Returns: $\\\\left\\\\{ \\\\begin{matrix} j_1 & j_2 & j_3 \\\\\\\\ J_1 & J_2 & J_3 \\\\end{matrix} \\\\right\\\\}$ \"\"\" if ( j1 , j2 , j3 , J1 , J2 , J3 ) in _wigner_6j_cache : return _wigner_6j_cache [( j1 , j2 , j3 , J1 , J2 , J3 )] if ( not ishalfint ( j1 ) or not ishalfint ( j2 ) or not ishalfint ( j3 ) or not ishalfint ( J1 ) or not ishalfint ( J2 ) or not ishalfint ( J3 ) ): raise ValueError ( \"All arguments must be integers or half-integers\" ) # triangle inequality for each triad if ( not istriangle ( j1 , j2 , j3 ) or not istriangle ( j1 , J2 , J3 ) or not istriangle ( J1 , j2 , J3 ) or not istriangle ( J1 , J2 , j3 ) ): return 0 # each triad must sum to an integer if ( not isint ( j1 + j2 + j3 ) or not isint ( j1 + J2 + J3 ) or not isint ( J1 + j2 + J3 ) or not isint ( J1 + J2 + j3 ) ): return 0 wigner = 0 for t in range ( int ( max ( 0 , j1 + j2 + j3 , j1 + J2 + J3 , J1 + j2 + J3 , J1 + J2 + j3 )), int ( min ( j1 + j2 + J1 + J2 , j2 + j3 + J2 + J3 , j3 + j1 + J3 + J1 )) + 1 , ): wigner += ( ( - 1 ) ** t * factorial ( t + 1 ) / ( factorial ( t - ( j1 + j2 + j3 )) * factorial ( t - ( j1 + J2 + J3 )) * factorial ( t - ( J1 + j2 + J3 )) * factorial ( t - ( J1 + J2 + j3 )) * factorial (( j1 + j2 + J1 + J2 ) - t ) * factorial (( j2 + j3 + J2 + J3 ) - t ) * factorial (( j3 + j1 + J3 + J1 ) - t ) ) ) wigner *= sqrt ( \u0394 ( j1 , j2 , j3 ) * \u0394 ( j1 , J2 , J3 ) * \u0394 ( J1 , j2 , J3 ) * \u0394 ( J1 , J2 , j3 )) _wigner_6j_cache [( j1 , j2 , j3 , J1 , J2 , J3 )] = wigner return wigner \u0394 ( a , b , c ) Helper function for wigner symbols Calculates the intermediate expression \\(\\Delta = \\frac{(a+b-c)!(a-b+c)!(-a+b+c)!}{(a+b+c+1)!}\\) Parameters: Name Type Description Default a float required b float required c float required Returns: Type Description float \\(\\Delta\\) Source code in atomphys/calc/wigner.py def \u0394 ( a : float , b : float , c : float ) -> float : \"\"\"Helper function for wigner symbols Calculates the intermediate expression $\\\\Delta = \\\\frac{(a+b-c)!(a-b+c)!(-a+b+c)!}{(a+b+c+1)!}$ Arguments: a: b: c: Returns: $\\\\Delta$ \"\"\" return ( factorial ( a + b - c ) * factorial ( a - b + c ) * factorial ( - a + b + c ) / factorial ( a + b + c + 1 ) ) states Coupling ( Enum ) An enumeration. parse_term ( term ) parse term symbol string Source code in atomphys/states.py def parse_term ( term ): \"\"\" parse term symbol string \"\"\" if term == \"Limit\" : return {} parity = - 1 if \"*\" in term else 1 match = LS_term . match ( term ) if match is None : match = JJ_term . match ( term ) if match is None : match = LK_term . match ( term ) if match is None : return { \"partiy\" : parity } def convert ( key , value ): if key == \"S\" : return float ( Fraction (( int ( value ) - 1 ) / 2 )) if key == \"J1\" or key == \"J2\" or key == \"K\" : return float ( Fraction ( value )) if key == \"L\" : return L [ value ] term = { key : convert ( key , value ) for key , value in match . groupdict () . items ()} return { ** term , \"parity\" : parity } util fsolve ( func , x0 , x1 = None , tol = 1.49012e-08 , maxfev = 100 ) Find the roots of a function. Return the roots of the equation func(x) = 0 given a starting estimate x0 . A second starting estimate x1 can be used to bound a root if f(x) has multiple roots. Parameters: Name Type Description Default func Callable a function f(x) that takes a single argument x required x0 The starting estimate for the roots of `func(x) = 0`` required x1 A secton starting estimate that together with x1 bounds the root. Defaults to 1.0001 * x0 . None tol float The calculation will terminate if the relative error between two consecutive iterates is at most tol 1.49012e-08 maxfev int The maximum number of calls to the function. 100 Source code in atomphys/util.py def fsolve ( func : Callable , x0 , x1 = None , tol : float = 1.49012e-08 , maxfev : int = 100 ): \"\"\" Find the roots of a function. Return the roots of the equation `func(x) = 0` given a starting estimate `x0`. A second starting estimate `x1` can be used to bound a root if `f(x)` has multiple roots. Arguments: func: a function `f(x)` that takes a single argument `x` x0: The starting estimate for the roots of `func(x) = 0`` x1: A secton starting estimate that together with `x1` bounds the root. Defaults to `1.0001 * x0`. tol: The calculation will terminate if the relative error between two consecutive iterates is at most `tol` maxfev: The maximum number of calls to the function. \"\"\" if x1 is None : x1 = x0 * 1.001 fx0 , fx1 = func ( x0 ), func ( x1 ) i = 2 while ( abs ( fx0 ) > 0 ) and ( abs (( fx1 - fx0 ) / fx0 ) > tol ) and ( i < maxfev + 1 ): x2 = x1 - fx1 * ( x1 - x0 ) / ( fx1 - fx0 ) x0 , x1 = x1 , x2 fx0 , fx1 = fx1 , func ( x1 ) i += 1 return x1 sanitize_energy ( s ) sanitize energy strings from NIST ASD by removing annotations Source code in atomphys/util.py def sanitize_energy ( s : str ) -> str : \"\"\"sanitize energy strings from NIST ASD by removing annotations\"\"\" # return re_energy.findall(s)[0] # this is about 3.5\u00d7 faster than re.findall, but it's less flexible # overall this can make a several hundred ms difference when loading return s . strip ( \"()[]aluxyz +?\" ) . replace ( \"&dagger;\" , \"\" )","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#atomphys.atom","text":"","title":"atom"},{"location":"reference/#atomphys.atom.Atom","text":"An atom object, containing states and transitions Attributes: Name Type Description name str The name of the atom","title":"Atom"},{"location":"reference/#atomphys.atom.Atom.states","text":"StateRegistry: the atomic states.","title":"states"},{"location":"reference/#atomphys.atom.Atom.transitions","text":"TransitionRegistry: the atomic transitions.","title":"transitions"},{"location":"reference/#atomphys.atom.Atom.units","text":"pint.UnitRegistry(): readonly access to the pint UnitRegistry used by the atom.","title":"units"},{"location":"reference/#atomphys.calc","text":"","title":"calc"},{"location":"reference/#atomphys.calc.polarizability","text":"","title":"polarizability"},{"location":"reference/#atomphys.calc.polarizability.scalar","text":"Calculate the scalar polarizability of a state |\u03a8\u27e9 Approximate the dynamical scalar polarizability \u03b10(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements \\[ \\alpha^0(\\omega) = \\frac{1}{3(2J+1)} \\sum_i \\left( \\frac{1}{\\hbar (E_i - E) - \\hbar \\omega} + \\frac{1}{\\hbar (E_i - E) + \\hbar \\omega} \\right) \\left|\\left<\\Psi\\left|D\\right| \\Psi_i\\right>\\right|^2 \\] Parameters: Name Type Description Default state State state |\u03a8\u27e9 to calculate the polarizability required omega Quantity Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of Hz . 0 Returns: Type Description Quantity Scalar polarizability. Has units of C m / (V/m) , or dipole moment / electric field. Source code in atomphys/calc/polarizability.py def scalar ( state , omega : pint . Quantity = 0 ) -> pint . Quantity : \"\"\"Calculate the scalar polarizability of a state |\u03a8\u27e9 Approximate the dynamical scalar polarizability \u03b10(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements $$ \\\\alpha^0(\\\\omega) = \\\\frac{1}{3(2J+1)} \\\\sum_i \\\\left( \\\\frac{1}{\\\\hbar (E_i - E) - \\\\hbar \\\\omega} + \\\\frac{1}{\\\\hbar (E_i - E) + \\\\hbar \\\\omega} \\\\right) \\\\left|\\\\left<\\\\Psi\\\\left|D\\\\right| \\\\Psi_i\\\\right>\\\\right|^2 $$ Arguments: state (State): state |\u03a8\u27e9 to calculate the polarizability omega: Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of `Hz`. Returns: Scalar polarizability. Has units of `C m / (V/m)`, or dipole moment / electric field. \"\"\" \u03c9 = omega \u0127 = state . _ureg [ \"\u0127\" ] J = state . J X = 1 / ( 3 * ( 2 * J + 1 )) / \u0127 \u03b1 = 0 for transition in state . up : \u03c90 = transition . \u03c9 d = transition . reduced_dipole_matrix_element \u03b1 += ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 for transition in state . down : \u03c90 = - transition . \u03c9 d = transition . reduced_dipole_matrix_element_conjugate \u03b1 += ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 return ( \u03b1 * X ) . to_base_units ()","title":"scalar()"},{"location":"reference/#atomphys.calc.polarizability.tensor","text":"Calculate the tensor polarizability of a state |\u03a8\u27e9 Approximate the dynamical tensor polarizability \u03b10(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements \\[ \\alpha^1(\\omega) = -\\sqrt{\\frac{20J(2J-1)}{6(J+1)(2J+1)(2J+3)}} \\sum_i \\left\\{ \\begin{matrix} 1 & 1 & 1 \\\\ J & J & J_i \\end{matrix} \\right\\} (-1)^{1+J+J_i} \\left( \\frac{1}{\\hbar (E_i - E) - \\hbar \\omega} + \\frac{1}{\\hbar (E_i - E) + \\hbar \\omega}\\right) \\left| \\left<\\Psi\\left|D\\right| \\Psi_i\\right>\\right|^2 \\] Parameters: Name Type Description Default state State state |\u03a8\u27e9 to calculate the polarizability required omega Quantity Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of Hz . 0 Returns: Type Description Tensor polarizability. Has units of C m / (V/m) , or dipole moment / electric field. Source code in atomphys/calc/polarizability.py def tensor ( state , omega : pint . Quantity = 0 ): \"\"\"Calculate the tensor polarizability of a state |\u03a8\u27e9 Approximate the dynamical tensor polarizability \u03b10(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements \\\\[ \\\\alpha^1(\\\\omega) = -\\\\sqrt{\\\\frac{20J(2J-1)}{6(J+1)(2J+1)(2J+3)}} \\\\sum_i \\\\left\\\\{ \\\\begin{matrix} 1 & 1 & 1 \\\\\\\\ J & J & J_i \\\\end{matrix} \\\\right\\\\} (-1)^{1+J+J_i} \\\\left( \\\\frac{1}{\\\\hbar (E_i - E) - \\\\hbar \\\\omega} + \\\\frac{1}{\\\\hbar (E_i - E) + \\\\hbar \\\\omega}\\\\right) \\\\left| \\\\left<\\\\Psi\\\\left|D\\\\right| \\\\Psi_i\\\\right>\\\\right|^2 \\\\] Arguments: state (State): state |\u03a8\u27e9 to calculate the polarizability omega: Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of `Hz`. Returns: Tensor polarizability. Has units of `C m / (V/m)`, or dipole moment / electric field. \"\"\" \u03c9 = omega \u0127 = state . _ureg [ \"\u0127\" ] J = state . J X = ( - ( (( 20 * J * ( 2 * J - 1 )) / ( 6 * ( J + 1 ) * ( 2 * J + 1 ) * ( 2 * J + 3 ))) ** ( 1 / 2 ) ) / \u0127 ) \u03b1 = 0 for transition in state . up : \u03c90 = transition . \u03c9 d = transition . reduced_dipole_matrix_element Jp = transition . f . J sixJ = wigner_6j ( 1 , 1 , 2 , J , J , Jp ) \u03b1 += ( - 1 ) ** ( J + Jp + 1 ) * sixJ * ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 for transition in state . down : \u03c90 = - transition . \u03c9 d = transition . reduced_dipole_matrix_element_conjugate Jp = transition . i . J sixJ = wigner_6j ( 1 , 1 , 2 , J , J , Jp ) \u03b1 += ( - 1 ) ** ( J + Jp + 1 ) * sixJ * ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 return ( \u03b1 * X ) . to_base_units ()","title":"tensor()"},{"location":"reference/#atomphys.calc.polarizability.total","text":"Calculate the polarizability of a state for a given field polarization Calculates the dynamical polarizability \u03b1(\u03c9) by taking the sum of the scalar, vector, and tensor poarts according to \\[ \\alpha(\\omega) = \\alpha^0(\\omega) + A \\cos(\\theta_k) \\frac{m_J}{2J} \\alpha^1(\\omega) + \\frac{1}{2}\\left(3 \\cos^2(\\theta_p) - 1\\right)\\frac{3m_J^2 - J(J+1)}{J(2J-1)}\\alpha^2(\\omega) \\] Parameters: Name Type Description Default state State state |\u03a8\u27e9 to calculate the polarizability required mJ float Zeeman sublevel to calculate the vector and tensor polarizability. If None only calculates the scalar component. Must be an integer if J is an integer, or a half-integer if J is a half integer. None omega Quantity angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of Hz . 0 A float degree of circular polarization, with \u00b11 being circular polarization and 0 being linear polarization 0 theta_k float angle between wave vector and quantization axis 0 theta_p float angle between polarization vector and quantization axis 1.5707963267948966 Returns: Type Description Quantity Polarizability. Has units of C m / (V/m) , or dipole moment / electric field. Source code in atomphys/calc/polarizability.py def total ( state , mJ : float = None , omega : pint . Quantity = 0 , A : float = 0 , theta_k : float = 0 , theta_p : float = \u03c0 / 2 , ) -> pint . Quantity : \"\"\"Calculate the polarizability of a state for a given field polarization Calculates the dynamical polarizability \u03b1(\u03c9) by taking the sum of the scalar, vector, and tensor poarts according to \\\\[ \\\\alpha(\\\\omega) = \\\\alpha^0(\\\\omega) + A \\\\cos(\\\\theta_k) \\\\frac{m_J}{2J} \\\\alpha^1(\\\\omega) + \\\\frac{1}{2}\\\\left(3 \\\\cos^2(\\\\theta_p) - 1\\\\right)\\\\frac{3m_J^2 - J(J+1)}{J(2J-1)}\\\\alpha^2(\\\\omega) \\\\] Arguments: state (State): state |\u03a8\u27e9 to calculate the polarizability mJ: Zeeman sublevel to calculate the vector and tensor polarizability. If `None` only calculates the scalar component. Must be an integer if J is an integer, or a half-integer if J is a half integer. omega: angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of `Hz`. A: degree of circular polarization, with \u00b11 being circular polarization and 0 being linear polarization theta_k: angle between wave vector and quantization axis theta_p: angle between polarization vector and quantization axis Returns: Polarizability. Has units of `C m / (V/m)`, or dipole moment / electric field. Raises: ZeroDivisionError \"\"\" \u03b8k = theta_k \u03b8p = theta_p J = state . J \u03b10 = scalar ( state , omega ) \u03b11 = vector ( state , omega ) \u03b12 = tensor ( state , omega ) if mJ is None : return \u03b10 if not ( isint ( mJ ) or ( ishalfint ( mJ ) and ishalfint ( J ))): raise ValueError ( \"mJ must be an integer, or a half-integer if J is a half-integer\" ) C1 = A * cos ( \u03b8k ) * mJ / J try : C2 = ( ( 3 * cos ( \u03b8p ) ** 2 - 1 ) / 2 * ( 3 * mJ ** 2 - J * ( J + 1 )) / ( J * ( 2 * J - 1 )) ) except ZeroDivisionError : C2 = 0 return ( \u03b10 + C1 * \u03b11 + C2 * \u03b12 ) . to_base_units ()","title":"total()"},{"location":"reference/#atomphys.calc.polarizability.vector","text":"Calculate the vector polarizability of a state |\u03a8\u27e9 Approximate the dynamical vector polarizability \u03b11(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements \\[ \\alpha^1(\\omega) = \\sqrt{\\frac{6J}{(J+1)(2J+1)}} \\sum_i \\left\\{ \\begin{matrix} 1 & 1 & 1 \\\\ J & J & J_i \\end{matrix} \\right\\} (-1)^{1+J+J_i} \\left( \\frac{1}{\\hbar (E_i - E) - \\hbar \\omega} + \\frac{1}{\\hbar (E_i - E) + \\hbar \\omega} \\right) \\left|\\left<\\Psi\\left|D\\right| \\Psi_i\\right>\\right|^2 \\] Parameters: Name Type Description Default state State state |\u03a8\u27e9 to calculate the polarizability required omega Quantity Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of Hz . 0 Returns: Type Description Vector polarizability. Has units of C m / (V/m) , or dipole moment / electric field. Source code in atomphys/calc/polarizability.py def vector ( state , omega : pint . Quantity = 0 ): \"\"\"Calculate the vector polarizability of a state |\u03a8\u27e9 Approximate the dynamical vector polarizability \u03b11(\u03c9) of the state |\u03a8\u27e9 by summing over matrix elements \\\\[ \\\\alpha^1(\\\\omega) = \\\\sqrt{\\\\frac{6J}{(J+1)(2J+1)}} \\\\sum_i \\\\left\\\\{ \\\\begin{matrix} 1 & 1 & 1 \\\\\\\\ J & J & J_i \\\\end{matrix} \\\\right\\\\} (-1)^{1+J+J_i} \\\\left( \\\\frac{1}{\\\\hbar (E_i - E) - \\\\hbar \\\\omega} + \\\\frac{1}{\\\\hbar (E_i - E) + \\\\hbar \\\\omega} \\\\right) \\\\left|\\\\left<\\\\Psi\\\\left|D\\\\right| \\\\Psi_i\\\\right>\\\\right|^2 \\\\] Arguments: state (State): state |\u03a8\u27e9 to calculate the polarizability omega: Angular frequency of the field to calculate the dynamical polarizability. Defaults to zero, in which case it calculates the static polarizability. Must have units of `Hz`. Returns: Vector polarizability. Has units of `C m / (V/m)`, or dipole moment / electric field. \"\"\" \u03c9 = omega \u0127 = state . _ureg [ \"\u0127\" ] J = state . J X = (( 6 * J ) / ( 4 * ( 2 * J + 1 ) * ( J + 1 ))) ** ( 1 / 2 ) / \u0127 \u03b1 = 0 for transition in state . up : \u03c90 = transition . \u03c9 d = transition . reduced_dipole_matrix_element Jp = transition . f . J sixJ = wigner_6j ( 1 , 1 , 1 , J , J , Jp ) \u03b1 += ( - 1 ) ** ( J + Jp + 1 ) * sixJ * ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 for transition in state . down : \u03c90 = - transition . \u03c9 d = transition . reduced_dipole_matrix_element_conjugate Jp = transition . i . J sixJ = wigner_6j ( 1 , 1 , 1 , J , J , Jp ) \u03b1 += - (( - 1 ) ** ( J + Jp + 1 )) * sixJ * ( 1 / ( \u03c90 - \u03c9 ) + 1 / ( \u03c90 + \u03c9 )) * d ** 2 return ( \u03b1 * X ) . to_base_units ()","title":"vector()"},{"location":"reference/#atomphys.calc.wigner","text":"","title":"wigner"},{"location":"reference/#atomphys.calc.wigner.ishalfint","text":"check if value is half integer Parameters: Name Type Description Default x float is this a half integer? required Returns: Type Description bool True if x is a half integer and False if it is not. Source code in atomphys/calc/wigner.py def ishalfint ( x : float ) -> bool : \"\"\"check if value is half integer Arguments: x: is this a half integer? Returns: True if x is a half integer and False if it is not. \"\"\" return 2 * x == floor ( 2 * x )","title":"ishalfint()"},{"location":"reference/#atomphys.calc.wigner.isint","text":"checks if value is an integer Parameters: Name Type Description Default x float is this an integer? required Returns: Type Description bool True if x is an integer and False if it is not. Source code in atomphys/calc/wigner.py def isint ( x : float ) -> bool : \"\"\"checks if value is an integer Arguments: x: is this an integer? Returns: True if x is an integer and False if it is not. \"\"\" return x == floor ( x )","title":"isint()"},{"location":"reference/#atomphys.calc.wigner.istriangle","text":"checks if triad (a, b, c) obeys the triangle inequality Parameters: Name Type Description Default a float required b float required c float required Returns: Type Description bool True if the triangle inequality is satisfied and False if it is not. Source code in atomphys/calc/wigner.py def istriangle ( a : float , b : float , c : float ) -> bool : \"\"\"checks if triad (a, b, c) obeys the triangle inequality Arguments: a: b: c: Returns: True if the triangle inequality is satisfied and False if it is not. \"\"\" return abs ( a - b ) <= c and c <= a + b","title":"istriangle()"},{"location":"reference/#atomphys.calc.wigner.wigner_3j","text":"Calculate the Wigner 3-j symbol numerically The Wigner 3-j symbol is calculated numerically using a recursion relation. This approximate calculation is often faster than the exact analytic calculation that is done by sympy.physics.wigner . Due to the finite precision of floating point numbers, this is only good for \\(j\\) and \\(m\\) up to about 40, after which it becomes too inaccurate. The results are cached in the private variable _wigner_3j_cache to speed subsequent calculations. \\(\\left( \\begin{matrix} j_1 & j_2 & j_3 \\\\ m_1 & m_2 & m_3 \\end{matrix} \\right)\\) Parameters: Name Type Description Default j1 float required j2 float required j3 float required m1 float required m2 float required m3 float required Returns: Type Description float \\(\\left( \\begin{matrix} j_1 & j_2 & j_3 \\\\ m_1 & m_2 & m_3 \\end{matrix} \\right)\\) Source code in atomphys/calc/wigner.py def wigner_3j ( j1 : float , j2 : float , j3 : float , m1 : float , m2 : float , m3 : float ) -> float : \"\"\"Calculate the Wigner 3-j symbol numerically The Wigner 3-j symbol is calculated numerically using a recursion relation. This approximate calculation is often faster than the exact analytic calculation that is done by `sympy.physics.wigner`. Due to the finite precision of floating point numbers, this is only good for $j$ and $m$ up to about 40, after which it becomes too inaccurate. The results are cached in the private variable `_wigner_3j_cache` to speed subsequent calculations. $\\\\left( \\\\begin{matrix} j_1 & j_2 & j_3 \\\\\\\\ m_1 & m_2 & m_3 \\\\end{matrix} \\\\right)$ Arguments: j1: j2: j3: m1: m2: m3: Returns: $\\\\left( \\\\begin{matrix} j_1 & j_2 & j_3 \\\\\\\\ m_1 & m_2 & m_3 \\\\end{matrix} \\\\right)$ \"\"\" if ( j1 , j2 , j3 , m1 , m2 , m3 ) in _wigner_3j_cache : return _wigner_3j_cache [( j1 , j2 , j3 , m1 , m2 , m3 )] if ( not ishalfint ( j1 ) or not ishalfint ( j2 ) or not ishalfint ( j3 ) or not ishalfint ( m1 ) or not ishalfint ( m2 ) or not ishalfint ( m3 ) ): raise ValueError ( \"All arguments must be integers or half-integers\" ) if j1 > 40 or j2 > 40 or j3 > 40 or m1 > 40 or m2 > 40 or m3 > 40 : raise OverflowError ( \"can't handle numbers this larger, use a sympy.physics.wigner\" ) # sum of second row must equal zero if m1 + m2 + m3 != 0 : return 0 # triangle inequality if not istriangle ( j1 , j2 , j3 ): return 0 if ( j1 - m1 != floor ( j1 - m1 ) or j2 - m2 != floor ( j2 - m2 ) or j3 - m3 != floor ( j3 - m3 ) ): return 0 if abs ( m1 ) > j1 or abs ( m2 ) > j2 or abs ( m3 ) > j3 : return 0 wigner = 0 for t in range ( int ( max ( 0 , j2 - m1 - j3 , j1 + m2 - j3 )), int ( min ( j1 + j2 - j3 , j1 - m1 , j2 + m2 )) + 1 , ): wigner += ( - 1 ) ** t / ( factorial ( t ) * factorial ( t - ( j2 - m1 - j3 )) * factorial ( t - ( j1 + m2 - j3 )) * factorial ( j1 + j2 - j3 - t ) * factorial ( j1 - m1 - t ) * factorial ( j2 + m2 - t ) ) wigner *= ( - 1 ) ** ( j1 - j2 - m3 ) * sqrt ( \u0394 ( j1 , j2 , j3 ) * factorial ( j1 + m1 ) * factorial ( j1 - m1 ) * factorial ( j2 + m2 ) * factorial ( j2 - m2 ) * factorial ( j3 + m3 ) * factorial ( j3 - m3 ) ) _wigner_3j_cache [( j1 , j2 , j3 , m1 , m2 , m3 )] = wigner return wigner","title":"wigner_3j()"},{"location":"reference/#atomphys.calc.wigner.wigner_6j","text":"Calculate the Wigner 6-j symbol numerically The Wigner 6-j symbol is calculated numerically using a recursion relation. This approximate calculation is often faster than the exact analytic calculation that is done by sympy.physics.wigner . The results are cached in the private variable _wigner_6j_cache to speed subsequent calculations. \\(\\left\\{ \\begin{matrix} j_1 & j_2 & j_3 \\\\ J_1 & J_2 & J_3 \\end{matrix} \\right\\}\\) Parameters: Name Type Description Default j1 float required j2 float required j3 float required J1 float required J2 float required J3 float required Returns: Type Description float \\(\\left\\{ \\begin{matrix} j_1 & j_2 & j_3 \\\\ J_1 & J_2 & J_3 \\end{matrix} \\right\\}\\) Source code in atomphys/calc/wigner.py def wigner_6j ( j1 : float , j2 : float , j3 : float , J1 : float , J2 : float , J3 : float ) -> float : \"\"\"Calculate the Wigner 6-j symbol numerically The Wigner 6-j symbol is calculated numerically using a recursion relation. This approximate calculation is often faster than the exact analytic calculation that is done by `sympy.physics.wigner`. The results are cached in the private variable `_wigner_6j_cache` to speed subsequent calculations. $\\\\left\\\\{ \\\\begin{matrix} j_1 & j_2 & j_3 \\\\\\\\ J_1 & J_2 & J_3 \\\\end{matrix} \\\\right\\\\}$ Arguments: j1: j2: j3: J1: J2: J3: Returns: $\\\\left\\\\{ \\\\begin{matrix} j_1 & j_2 & j_3 \\\\\\\\ J_1 & J_2 & J_3 \\\\end{matrix} \\\\right\\\\}$ \"\"\" if ( j1 , j2 , j3 , J1 , J2 , J3 ) in _wigner_6j_cache : return _wigner_6j_cache [( j1 , j2 , j3 , J1 , J2 , J3 )] if ( not ishalfint ( j1 ) or not ishalfint ( j2 ) or not ishalfint ( j3 ) or not ishalfint ( J1 ) or not ishalfint ( J2 ) or not ishalfint ( J3 ) ): raise ValueError ( \"All arguments must be integers or half-integers\" ) # triangle inequality for each triad if ( not istriangle ( j1 , j2 , j3 ) or not istriangle ( j1 , J2 , J3 ) or not istriangle ( J1 , j2 , J3 ) or not istriangle ( J1 , J2 , j3 ) ): return 0 # each triad must sum to an integer if ( not isint ( j1 + j2 + j3 ) or not isint ( j1 + J2 + J3 ) or not isint ( J1 + j2 + J3 ) or not isint ( J1 + J2 + j3 ) ): return 0 wigner = 0 for t in range ( int ( max ( 0 , j1 + j2 + j3 , j1 + J2 + J3 , J1 + j2 + J3 , J1 + J2 + j3 )), int ( min ( j1 + j2 + J1 + J2 , j2 + j3 + J2 + J3 , j3 + j1 + J3 + J1 )) + 1 , ): wigner += ( ( - 1 ) ** t * factorial ( t + 1 ) / ( factorial ( t - ( j1 + j2 + j3 )) * factorial ( t - ( j1 + J2 + J3 )) * factorial ( t - ( J1 + j2 + J3 )) * factorial ( t - ( J1 + J2 + j3 )) * factorial (( j1 + j2 + J1 + J2 ) - t ) * factorial (( j2 + j3 + J2 + J3 ) - t ) * factorial (( j3 + j1 + J3 + J1 ) - t ) ) ) wigner *= sqrt ( \u0394 ( j1 , j2 , j3 ) * \u0394 ( j1 , J2 , J3 ) * \u0394 ( J1 , j2 , J3 ) * \u0394 ( J1 , J2 , j3 )) _wigner_6j_cache [( j1 , j2 , j3 , J1 , J2 , J3 )] = wigner return wigner","title":"wigner_6j()"},{"location":"reference/#atomphys.calc.wigner.\u0394","text":"Helper function for wigner symbols Calculates the intermediate expression \\(\\Delta = \\frac{(a+b-c)!(a-b+c)!(-a+b+c)!}{(a+b+c+1)!}\\) Parameters: Name Type Description Default a float required b float required c float required Returns: Type Description float \\(\\Delta\\) Source code in atomphys/calc/wigner.py def \u0394 ( a : float , b : float , c : float ) -> float : \"\"\"Helper function for wigner symbols Calculates the intermediate expression $\\\\Delta = \\\\frac{(a+b-c)!(a-b+c)!(-a+b+c)!}{(a+b+c+1)!}$ Arguments: a: b: c: Returns: $\\\\Delta$ \"\"\" return ( factorial ( a + b - c ) * factorial ( a - b + c ) * factorial ( - a + b + c ) / factorial ( a + b + c + 1 ) )","title":"\u0394()"},{"location":"reference/#atomphys.states","text":"","title":"states"},{"location":"reference/#atomphys.states.Coupling","text":"An enumeration.","title":"Coupling"},{"location":"reference/#atomphys.states.parse_term","text":"parse term symbol string Source code in atomphys/states.py def parse_term ( term ): \"\"\" parse term symbol string \"\"\" if term == \"Limit\" : return {} parity = - 1 if \"*\" in term else 1 match = LS_term . match ( term ) if match is None : match = JJ_term . match ( term ) if match is None : match = LK_term . match ( term ) if match is None : return { \"partiy\" : parity } def convert ( key , value ): if key == \"S\" : return float ( Fraction (( int ( value ) - 1 ) / 2 )) if key == \"J1\" or key == \"J2\" or key == \"K\" : return float ( Fraction ( value )) if key == \"L\" : return L [ value ] term = { key : convert ( key , value ) for key , value in match . groupdict () . items ()} return { ** term , \"parity\" : parity }","title":"parse_term()"},{"location":"reference/#atomphys.util","text":"","title":"util"},{"location":"reference/#atomphys.util.fsolve","text":"Find the roots of a function. Return the roots of the equation func(x) = 0 given a starting estimate x0 . A second starting estimate x1 can be used to bound a root if f(x) has multiple roots. Parameters: Name Type Description Default func Callable a function f(x) that takes a single argument x required x0 The starting estimate for the roots of `func(x) = 0`` required x1 A secton starting estimate that together with x1 bounds the root. Defaults to 1.0001 * x0 . None tol float The calculation will terminate if the relative error between two consecutive iterates is at most tol 1.49012e-08 maxfev int The maximum number of calls to the function. 100 Source code in atomphys/util.py def fsolve ( func : Callable , x0 , x1 = None , tol : float = 1.49012e-08 , maxfev : int = 100 ): \"\"\" Find the roots of a function. Return the roots of the equation `func(x) = 0` given a starting estimate `x0`. A second starting estimate `x1` can be used to bound a root if `f(x)` has multiple roots. Arguments: func: a function `f(x)` that takes a single argument `x` x0: The starting estimate for the roots of `func(x) = 0`` x1: A secton starting estimate that together with `x1` bounds the root. Defaults to `1.0001 * x0`. tol: The calculation will terminate if the relative error between two consecutive iterates is at most `tol` maxfev: The maximum number of calls to the function. \"\"\" if x1 is None : x1 = x0 * 1.001 fx0 , fx1 = func ( x0 ), func ( x1 ) i = 2 while ( abs ( fx0 ) > 0 ) and ( abs (( fx1 - fx0 ) / fx0 ) > tol ) and ( i < maxfev + 1 ): x2 = x1 - fx1 * ( x1 - x0 ) / ( fx1 - fx0 ) x0 , x1 = x1 , x2 fx0 , fx1 = fx1 , func ( x1 ) i += 1 return x1","title":"fsolve()"},{"location":"reference/#atomphys.util.sanitize_energy","text":"sanitize energy strings from NIST ASD by removing annotations Source code in atomphys/util.py def sanitize_energy ( s : str ) -> str : \"\"\"sanitize energy strings from NIST ASD by removing annotations\"\"\" # return re_energy.findall(s)[0] # this is about 3.5\u00d7 faster than re.findall, but it's less flexible # overall this can make a several hundred ms difference when loading return s . strip ( \"()[]aluxyz +?\" ) . replace ( \"&dagger;\" , \"\" )","title":"sanitize_energy()"},{"location":"user_guide/atom/","text":"","title":"Atom"},{"location":"user_guide/laser/","text":"","title":"Laser"},{"location":"user_guide/state/","text":"","title":"State"},{"location":"user_guide/transition/","text":"","title":"Transision"}]}